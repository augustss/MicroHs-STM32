-- Copyright 2023 Lennart Augustsson
-- See LICENSE file for full license.
module Data.Char(
  Char, String,
  chr, ord,
  isLower, isUpper,
  isAsciiLower, isAsciiUpper,
  isAlpha, isLetter, isAlphaNum,
  isDigit, isOctDigit, isHexDigit,
  isNumber,
  isSymbol, isPunctuation,
  isSpace,
  isControl,
  isSeparator,
  isAscii, isLatin1,
  isPrint,
  digitToInt,
  intToDigit,
  toLower, toUpper,
  showLitChar,
  -- lexLitChar, readLitChar,
  -- XXX For now, don't import Text.Read, it's a bloated beast.
  ) where
import qualified Prelude()              -- do not import Prelude
import Primitives
import Control.Error
import Data.Bool
import Data.Bounded
import Data.Char_Type
import Data.Eq
import Data.Function
import Data.Int.Int
import Data.List_Type
import Data.Num
import Data.Ord
import Text.Show

instance Eq Char where
  (==) = primCharEQ
  (/=) = primCharNE

instance Ord Char where
  compare = primCharCompare
  (<)  = primCharLT
  (<=) = primCharLE
  (>)  = primCharGT
  (>=) = primCharGE

-- Using primitive comparison is still a small speedup, even using mostly bytestrings
instance Eq String where
  (==) = primStringEQ

instance Ord String where
  compare =  primStringCompare
  x <  y  =  case primStringCompare x y of { LT -> True; _ -> False }
  x <= y  =  case primStringCompare x y of { GT -> False; _ -> True }
  x >  y  =  case primStringCompare x y of { GT -> True; _ -> False }
  x >= y  =  case primStringCompare x y of { LT -> False; _ -> True }

instance Bounded Char where
  minBound = primChr 0
  maxBound = primChr 0x10ffff

chr :: Int -> Char
chr i = primChr i

ord :: Char -> Int
ord = primOrd

isLower :: Char -> Bool
isLower c = isAsciiLower c

isAsciiLower :: Char -> Bool
isAsciiLower c = 'a' <= c && c <= 'z'

isUpper :: Char -> Bool
isUpper c = isAsciiUpper c

isAsciiUpper :: Char -> Bool
isAsciiUpper c = 'A' <= c && c <= 'Z'

isAlpha :: Char -> Bool
isAlpha c = isLower c || isUpper c

isLetter :: Char -> Bool
isLetter = isAlpha

isDigit :: Char -> Bool
isDigit c = '0' <= c && c <= '9'

isOctDigit :: Char -> Bool
isOctDigit c = '0' <= c && c <= '7'

isHexDigit :: Char -> Bool
isHexDigit c = isDigit c || ('a' <= c && c <= 'f') || ('A' <= c && c <= 'F')

isAlphaNum :: Char -> Bool
isAlphaNum c = isAlpha c || isDigit c

isNumber :: Char -> Bool
isNumber c = isDigit c

isSymbol :: Char -> Bool
isSymbol c = c `xelem` "$+<=>^`|~"

isPunctuation :: Char -> Bool
isPunctuation c = c `xelem` "!\"#%&'()*,-./:;?@[\\]_{}"

-- Don't want to import Data.List
xelem :: Char -> [Char] -> Bool
xelem _ [] = False
xelem d (c:cs) = d == c || xelem d cs

isPrint :: Char -> Bool
isPrint c = ' ' <= c && c <= '~'

isSpace :: Char -> Bool
isSpace c = c `xelem` " \t\n\v\f\r"

isControl :: Char -> Bool
isControl c = c <= '\31' || c == '\127'

isSeparator :: Char -> Bool
isSeparator c = c == ' '

isAscii :: Char -> Bool
isAscii c = c <= '\127'

isLatin1 :: Char -> Bool
isLatin1 c = c <= '\255'

digitToInt :: Char -> Int
digitToInt c | primCharLE '0' c && primCharLE c '9' = ord c - ord '0'
             | primCharLE 'a' c && primCharLE c 'f' = ord c - (ord 'a' - 10)
             | primCharLE 'A' c && primCharLE c 'F' = ord c - (ord 'A' - 10)
             | otherwise                            = error "digitToInt"

intToDigit :: Int -> Char
intToDigit i | i < 10 = primChr (ord '0' + i)
             | otherwise = primChr (ord 'A' - 10 + i)

toLower :: Char -> Char
toLower c | isAsciiUpper c = primChr (ord c - ord 'A' + ord 'a')
          | True = c

toUpper :: Char -> Char
toUpper c | isAsciiLower c = primChr (ord c - ord 'a' + ord 'A')
          | True = c

instance Show Char where
  showsPrec _ '\'' = showString "'\\''"
  showsPrec _ c = showChar '\'' . showLitChar c . showChar '\''
  showList    s = showChar '"'  . f s
    where f [] = showChar '"'
          f (c:cs) =
            if c == '"' then showString "\\\"" . f cs
            else showLitChar c . f cs

-- XXX Very wrong for non-printable
showLitChar :: Char -> ShowS
showLitChar c s = c : s
